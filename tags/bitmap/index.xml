<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bitmap on 许王伟的个人博客</title>
    <link>https://xuwangwei93.github.io/tags/bitmap/</link>
    <description>Recent content in Bitmap on 许王伟的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 22 Sep 2020 22:20:18 +0800</lastBuildDate><atom:link href="https://xuwangwei93.github.io/tags/bitmap/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>用java实现Bitmap</title>
      <link>https://xuwangwei93.github.io/post/%E7%94%A8java%E5%AE%9E%E7%8E%B0bitmap/</link>
      <pubDate>Tue, 22 Sep 2020 22:20:18 +0800</pubDate>
      
      <guid>https://xuwangwei93.github.io/post/%E7%94%A8java%E5%AE%9E%E7%8E%B0bitmap/</guid>
      <description>我今天遇到的一个业务需求是这样的：给定一个范围比如1-1533，这是目标需要覆盖的范围，还有一些实际执行的范围，比如1-100、300-700、400-500、600-1600，然后判断实际有没有覆盖目标范围。我举的这个例子是没有覆盖的，101-299这个区间没有覆盖。我只能想到Redis里的Bitmap来解决这个问题，所以用java实现了Bitmap。
import java.util.Arrays; import java.util.Objects; /** * Bitmap * * @author xuwangwei * @since 2020-09-22 */ public class Bitmap { /** * 容量。例如，此值为100时表示第0位到第99位可用。 */ private int capacity; /** * 数组长度 */ private int length; /** * 数据 */ private long[] data; /** * 构造方法 * * @param capacity 容量。例如，此值为100时表示第0位到第99位可用。 */ public Bitmap(int capacity) { this.capacity = capacity; length = capacity &amp;gt;&amp;gt; 6; data = new long[length]; } /** * 将第{@code index}位设置为1或者0 * * @param index 下标 * @param value 布尔值。true会置为1，false会置为0。 */ public void setBit(int index, boolean value) { if (index &amp;gt;= capacity || index &amp;lt; 0) { return; } int arrIndex = index &amp;gt;&amp;gt; 6; int offset = index &amp;amp; 63; if (value) { data[arrIndex] = data[arrIndex] | (0b1 &amp;lt;&amp;lt; offset); } else { data[arrIndex] = data[arrIndex] &amp;amp; (~(0b1 &amp;lt;&amp;lt; offset)); } } /** * 将第{@code from}位至第{@code to}位设置为1或者0。含头含尾。 * * @param from 起始下标 * @param to 终止下标 * @param value 布尔值。true会置为1，false会置为0。 */ public void setBit(int from, int to, boolean value) { if (from &amp;gt; to) { throw new IllegalArgumentException(&amp;quot;起始下标不能大于终止下标&amp;quot;); } for (int i = from; i &amp;lt;= to &amp;amp;&amp;amp; i &amp;lt; capacity; i++) { setBit(i, value); } } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() !</description>
    </item>
    
  </channel>
</rss>
